<!DOCTYPE html>
<html>
    <body>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.0/pixi.min.js"></script>
        <script>
            /*
                Make pixi game
                1. Tilebased
                2. Move hero with WASD or arrow keys Done
                3. Prevent hero from moving into terrain it's not allowed on
                4. Prevent hero from moving onto other characters
            */
            let Application = PIXI.Application,
                loader = PIXI.loader,
                resources = PIXI.loader.resources,
                Sprite = PIXI.Sprite,
                Graphics = PIXI.Graphics;

            let app = new Application({
                width: 600,
                height: 600,
                antialias: true,
                transparent: false,
                resolution: 1
            });
            app.renderer.backgroundColor = 0xFFFFFF;
            app.renderer.view.style = "border:1px solid #000000;";

            document.body.appendChild(app.view);

            let gameHeight = app.renderer.view.height;
            let gameWidth = app.renderer.view.width;
            let tileSize = 40;
            let state;

            let trees = {{{trees}}};
            let gameWorld = {{{gameWorld}}};
            let tree;


            loader
                .add([
                    "../public/images/golem.png",
                    "../public/images/tree.png"
                ])
                .load(setup);

            function setup() {
                // Code that runs after loader is finished loading image.
                let tile = new Graphics();
                // Fills tiles with green and blue
                for (let i = 0; i < gameWidth/tileSize; i++) {
                    for (let j = 0; j < gameWidth/tileSize; j++) {
                        if (gameWorld[i][j] == 'D') {
                            tile.beginFill(0x136D15);
                        } else if (gameWorld[i][j] == 'W') {
                            tile.beginFill(0x0033cc);
                        }
                        tile.drawRect(j * tileSize, i * tileSize, tileSize, tileSize);
                        tile.endFill();
                    }
                }

                app.stage.addChild(tile);
                // draw tiles
                let x = tileSize;
                let y = tileSize;
                let line = new Graphics();
                line.lineStyle(2, 0x09370A, 1);
                while (x < gameHeight) {
                    line.moveTo(x, 0);
                    line.lineTo(x, gameHeight);
                    app.stage.addChild(line);
                    line.moveTo(0, y);
                    line.lineTo(gameWidth, y);
                    y += tileSize;
                    x += tileSize;
                };

                // draw heros
                let hero = new Sprite(resources["../public/images/golem.png"].texture);
                hero.width = tileSize;
                hero.height = tileSize;

                app.stage.addChild(hero);

                // movements
                let left = keyboard("ArrowLeft"),
                    up = keyboard("ArrowUp"),
                    right = keyboard("ArrowRight"),
                    down = keyboard("ArrowDown"),
                    left2 = keyboard("a"),
                    up2 = keyboard("w"),
                    right2 = keyboard("d"),
                    down2 = keyboard("s");

                // arrow keys
                left.press = () => {
                    hero.x -= tileSize;
                };
                up.press = () => {
                    hero.y -= tileSize;
                };
                down.press = () => {
                    hero.y += tileSize;
                };
                right.press = () => {
                    hero.x += tileSize;
                };

                // wasd
                let isCanDoingWalkingOnThis = (x, y) => {
                    x = x/tileSize;
                    y = y/tileSize;
                    // TODO Check if tile is water

                    // Check if any tree is on x AND y
                    // IF OPEN SPOT CAN WALK
                    for (let i = 0; i < trees.length; i++) {
                        let tree = trees[i];
                        if (tree.x == x && tree.y == y) {
                            return false;
                        }
                    }
                    return true;
                };
                left2.press = () => {
                    if (isCanDoingWalkingOnThis(hero.x - tileSize, hero.y))
                        hero.x -= tileSize;
                };
                up2.press = () => {
                    if (isCanDoingWalkingOnThis(hero.x, hero.y - tileSize))
                        hero.y -= tileSize;
                };
                down2.press = () => {
                    if (isCanDoingWalkingOnThis(hero.x, hero.y + tileSize))
                        hero.y += tileSize;
                };
                right2.press = () => {
                    if (isCanDoingWalkingOnThis(hero.x + tileSize, hero.y))
                        hero.x += tileSize;
                };

                // draw trees
                for (let i = 0; i < trees.length; i++) {
                    for (let j = 0; j < trees.length; j++) {
                        for (let treeIndex = 0; treeIndex < trees.length; treeIndex++) {
                            if (trees[treeIndex].x == j && trees[treeIndex].y == i) {
                                tree = new Sprite(resources["../public/images/tree.png"].texture);
                                tree.x = j * tileSize;
                                tree.y = i * tileSize;
                                tree.width = tileSize;
                                tree.height = tileSize;
                                app.stage.addChild(tree);
                            }
                        }
                    }
                }
                state = play;
                // idk
                app.ticker.add(delta => gameLoop(delta));
            }

            function gameLoop(delta) {
                state(delta);
            }

            function play(delta) {

            }

            // attempt to keep player in canvas window 
            function contain(sprite, container) {
                let collision = undefined;

                if (sprite.x < container.x) {
                    sprite.x = container.x;
                    collision = "left";
                }
                if (sprite.y < container.y) {
                    sprite.y = container.y;
                    collision = "top";
                }
                if (sprite.x + sprite.width  > container.width) {
                    sprite.x = container.width - sprite.width;
                    collision = "right";
                }
                if (sprite.y > container.height) {
                    sprite.y = container.height - sprite.height;
                    collision = "bottom";
                }

                return collision;
            }

            function keyboard(value) {
                let key = {};
                key.value = value;
                key.isDown = false;
                key.isUp = true;
                key.press = undefined;
                key.release = undefined;

                key.downHandler = event => {
                    if (event.key === key.value) {
                        if (key.isUp && key.press) key.press();
                        key.isDown = true;
                        key.isUp = false;
                        event.preventDefault();
                    }
                };

                key.upHandler = event => {
                    if (event.key === key.value) {
                        if (key.isDown && key.release) key.release();
                        key.isDown = false;
                        key.isUp = true;
                        event.preventDefault();
                    }
                };

                const downListener = key.downHandler.bind(key);
                const upListener = key.upHandler.bind(key);

                window.addEventListener(
                    "keydown", downListener, false
                    );
                window.addEventListener(
                    "keyup", upListener, false
                    );

                key.unsubscribe = () => {
                    window.removeEventListener("keydown", downListener);
                    window.removeEventListener("keyup", upListener);
                };
                
                return key;
            }

        </script>
    </body>
</html>
